from os import stat
from types import DynamicClassAttribute

import logging
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from pandas.core.arrays.sparse import dtype
from pykalman import KalmanFilter

from TFM import DPF, Vectors


class TFF(Vectors):
    @property
    def _constructor(self):
        return TFF

    @classmethod
    def load_TFF(cls, path: str) -> "TFF":
        file = open(path, "r")
        data = file.read()
        data = [s.split() for s in data.split("\n")]
        df = pd.DataFrame(
            data, columns=["x", "y", "vx", "vy", "m"], dtype=np.float64
        ).dropna()
        return TFF(df).confirm()

    @classmethod
    def generate_TFF(
        cls, nCol: int, nRow: int, size: int, mode: str = "cGL", info: dict = None
    ) -> list:
        """Return a list of TFF objects which are generated by artificial means

        Args:
            nCol (int): the number of x points
            nRow (int): the number of y points
            size (int): the number of TFF objects
            mode (str, optional): the way how to synthesize traction force field. Defaults to "cGL".
                cGL : https://codeinthehole.com/tutorial/index.html
            info (dict, optional): the parameters for each mode. Defaults to None.

        Returns:
            list: list of TFF objects
        """
        dx = info["dx"]
        Wx = np.random.normal(0, 1, (nCol, nRow))[8::16, 8::16]
        Wy = np.random.normal(0, 1, (nCol, nRow))[8::16, 8::16]
        X, Y = np.meshgrid(
            np.arange(8, nCol * dx, 16), np.arange(8, nRow * dx, 16)
        )  # メッシュ生成
        res = []
        for _ in range(size):
            Wx, Wy = cls._update(Wx=Wx, Wy=Wy, mode=mode, info=info)

            df = TFF(
                {
                    "x": X.flatten(),
                    "y": Y.flatten(),
                    "vx": Wx.flatten(),
                    "vy": Wy.flatten(),
                    "m": np.sqrt(Wx ** 2 + Wy ** 2).flatten(),
                }
            )
            res.append(df)
        return res

    @classmethod
    def FFTC(
        cls,
        disXY: "DPF",
        pixel: float = 0.090,
        mu: float = 0.5,
        E: float = 5000,
        L: float = 0,
    ) -> "TFF":
        """
        Estimate traction force field from displacement field by Fourier transform traction cytometry (FFTC)
        https://www.cell.com/biophysj/pdf/S0006-3495(08)70780-X.pdf
        
        This program refers to https://github.com/qztseng/imagej_plugins/blob/master/current/src/FTTC/FTTC_.java
        Args:
            disXY (DPF): the target displacement field
            pixel (float): pixel length in micron
            mu (float): the poission ratio of gel
            E (float): Young's modulus of gel
            L (float): lambda parameter for the regularization kernel (0th order regularization)

        Returns:
            TFF: Estimated Traction Force Field
        """

        dim = disXY.get_Dimensions()

        # get disformation and coordinate
        disX = disXY.rearrange_by_coordinate("vx")
        disX *= pixel
        disY = disXY.rearrange_by_coordinate("vy")
        disY *= pixel
        gridX = disXY.loc[:, "x"]
        gridY = disXY.loc[:, "y"]

        # get shape info
        nCol, nRow, dPixel = dim
        D = dPixel * pixel

        # FFT
        disXCF = np.fft.fft2(disX)
        disYCF = np.fft.fft2(disY)
        disXCF[0, 0] = 0
        disYCF[0, 0] = 0

        # wave function in fourier space
        Kx = cls._get_Wavefunction_in_FS(nCol, D)
        Ky = cls._get_Wavefunction_in_FS(nRow, D)

        # calculate convolution

        # H is the regularization
        # G is Green function
        H = np.identity(2, dtype=np.complex) * L * L
        G = np.zeros([2, 2], dtype=np.complex)
        TractionXF = np.zeros([nRow, nCol], dtype=np.complex)
        TractionYF = np.zeros([nRow, nCol], dtype=np.complex)
        for i in range(len(Ky)):
            for j in range(len(Kx)):
                flag = cls._is_edge(j, i, nCol, nRow)
                G = cls._calc_Green(Kx[j], Ky[i], flag, mu, E)
                Gt = G.T
                G1 = Gt @ G
                G1 += H
                Ginv = np.linalg.inv(G1)

                dd = np.array([disXCF[i, j], disYCF[i, j]])
                GtU = Gt @ dd
                TXY = Ginv @ GtU
                TractionXF[i, j] = TXY[0]
                TractionYF[i, j] = TXY[1]
        TractionXF[0, 0] = 0
        TractionYF[0, 0] = 0

        # invert fft
        TractionXF = np.fft.ifft2(TractionXF)
        TractionYF = np.fft.ifft2(TractionYF)

        TractionXR = TractionXF.real.flatten()
        TractionYR = TractionYF.real.flatten()
        magnitude = np.sqrt(TractionXR ** 2 + TractionYR ** 2)
        df = pd.DataFrame(
            {
                "x": gridX,
                "y": gridY,
                "vx": TractionXR,
                "vy": TractionYR,
                "m": magnitude,
            }
        )
        return TFF(df).confirm()

    @classmethod
    def kalman_FFTC(
        cls,
        data: list,
        initial_dpf: "DPF" = None,
        pixel: float = 0.090,
        mu: float = 0.5,
        E: float = 5000,
        L: float = 0,
    ) -> "TFF":
        """
        Estimate traction force fields from a list of dipslacement fields by usign kalman-smoother
        Args:
            data (list[DPF]): list of displacement field
            initial_dpf (DPF): the dispacement field for the initial state (traction force filed)
            mu (float): the poission ratio of gel
            E (float): Young's modulus of gel
            L (float): lambda parameter for the regularization kernel (0th order regularization)
        Returns:
            list[TFF]: Estimated traction force fields
        """
        logging.info("Kalman smoother for T_(t+1) ~ T_t")
        # use the first data as initial state
        if initial_dpf is None:
            initial_dpf = data[0]
            data = data[1:]
        nCol, nRow, dPixel = initial_dpf.get_Dimensions()
        D = dPixel * pixel

        # convert raw data to process kalman-filter in fourier space
        logging.info("Get train data")
        train = TFF._get_train_data(data, pixel)

        initial_tff = TFF.FFTC(initial_dpf)
        tffXCF = TFF._fft_for_vectors(initial_tff, "vx").stack()
        tffYCF = TFF._fft_for_vectors(initial_tff, "vy").stack()

        # split complex data to real part and imaginary part
        tffXR, tffXI = TFF._convert_complex_to_vectors(tffXCF)
        tffYR, tffYI = TFF._convert_complex_to_vectors(tffYCF)

        # sort by xi_real, yi_real, xi_imag, yi_imag
        initial_state_vectors = (
            pd.concat([tffXR, tffYR, tffXI, tffYI]).sort_index().astype("float64")
        )

        # set obervation matrix
        # beta_(t+1) ~ beta_t
        # the vectors should be arranged by (xi_real, yi_real, xi_imag, yi_imag)
        logging.info("Get observation matrix")
        H = TFF._set_observation_matrix(nCol, nRow, D, mu=mu, E=E, L=L)

        kf = KalmanFilter(
            n_dim_obs=initial_state_vectors.shape[0],
            n_dim_state=initial_state_vectors.shape[0],
            initial_state_mean=initial_state_vectors.values,
            initial_state_covariance=np.identity(initial_state_vectors.shape[0]),
            transition_matrices=np.identity(initial_state_vectors.shape[0]),
            observation_matrices=H,
            observation_covariance=np.identity(initial_state_vectors.shape[0]),
            transition_covariance=np.identity(initial_state_vectors.shape[0]),
        )
        em_vars = [
            "initial_state_covariance",
            "observation_covariance",
            "transition_covariance",
        ]
        logging.info(f"EM-algorithm for {em_vars}")
        emed_kf = kf.em(train, em_vars=em_vars,)
        logging.info("Start kalman-smoother")
        smoothed_state_means, smoothed_state_covs = emed_kf.smooth(train)
        logging.info("Done")

        # reconstruct traction force filed from czomplex matrix
        result = []
        for i in range(len(smoothed_state_means)):
            res_XR = smoothed_state_means[i, ::4]
            res_YR = smoothed_state_means[i, 1::4]
            res_XI = smoothed_state_means[i, 2::4]
            res_YI = smoothed_state_means[i, 3::4]
            resXCF = res_XR + 1j * res_XI
            resYCF = res_YR + 1j * res_YI
            res_XCF = pd.DataFrame(resXCF, index=tffXCF.index)
            res_YCF = pd.DataFrame(resYCF, index=tffYCF.index)

            res_TractionXF = np.fft.ifft2(res_XCF.unstack().values)
            res_TractionYF = np.fft.ifft2(res_YCF.unstack().values)
            res_TractionXR = res_TractionXF.real.flatten()
            res_TractionYR = res_TractionYF.real.flatten()
            res_magnitude = np.sqrt(res_TractionXR ** 2 + res_TractionYR ** 2)
            res = TFF(
                {
                    "x": initial_tff.loc[:, "x"],
                    "y": initial_tff.loc[:, "y"],
                    "vx": res_TractionXR,
                    "vy": res_TractionYR,
                    "m": res_magnitude,
                }
            ).confirm()
            result.append(res)
        return result

    def convert_to_dpf(
        self, pixel: float = 0.090, mu: float = 0.5, E: float = 5000, L: float = 0,
    ) -> "DPF":
        """
        Convert traction force field to displacement field by inverting FFTC

        Returns:
            DPF: calculated displacement field
        """
        gridX = self.loc[:, "x"]
        gridY = self.loc[:, "y"]

        # the shape of _fft_for_vectors is 2D, so change to 1D
        tffXCF = self._fft_for_vectors(self, "vx").stack()
        tffYCF = self._fft_for_vectors(self, "vy").stack()

        nCol, nRow, dPixel = self.get_Dimensions()
        D = dPixel * pixel

        # wave function in fourier space
        Kx = self._get_Wavefunction_in_FS(nCol, D)
        Ky = self._get_Wavefunction_in_FS(nRow, D)

        G = np.zeros([2, 2], dtype=np.complex)
        disXCF = np.zeros([nRow, nCol], dtype=np.complex)
        disYCF = np.zeros([nRow, nCol], dtype=np.complex)

        for i in range(len(Ky)):
            for j in range(len(Kx)):
                flag = self._is_edge(j, i, nCol, nRow)
                G = self._calc_Green(Kx[j], Ky[i], flag, mu, E)
                dd = np.array([tffXCF[i, j], tffYCF[i, j]])
                TXY = G @ dd
                disXCF[i, j] = TXY[0]
                disYCF[i, j] = TXY[1]

        disXCF[0, 0] = 0
        disYCF[0, 0] = 0

        # invert fft
        disXF = np.fft.ifft2(disXCF)
        disYF = np.fft.ifft2(disYCF)

        disXR = disXF.real.flatten() / pixel
        disYR = disYF.real.flatten() / pixel
        magnitude = np.sqrt(disXR ** 2 + disYR ** 2)
        df = DPF({"x": gridX, "y": gridY, "vx": disXR, "vy": disYR, "m": magnitude,})
        return df.confirm()

    @staticmethod
    def _calc_Green(
        kx: float, ky: float, is_edge: bool, mu: float = 0.5, E: float = 5000,
    ) -> np.array:
        G = np.zeros([2, 2], dtype=np.complex)
        k = np.sqrt(kx * kx + ky * ky)
        if is_edge:
            G[0, 1] = 0
            G[1, 0] = 0
        else:
            gg = -mu * kx * ky
            G[0, 1] = gg
            G[1, 0] = gg
        G0 = 2 * (1 + mu) / (E * pow(k, 3))
        G[0, 0] = (1 - mu) * (k * k) + mu * (ky * ky)
        G[1, 1] = (1 - mu) * (k * k) + mu * (kx * kx)
        G *= G0
        return G

    @staticmethod
    def _calc_Laplacian(Tv: np.ndarray):
        lap = np.zeros(Tv.shape)
        lap[1:-1, 1:-1] = (
            -4 * Tv[1:-1, 1:-1]
            + Tv[:-2, 1:-1]
            + Tv[2:, 1:-1]
            + Tv[1:-1, :-2]
            + Tv[1:-1, 2:]
        )
        lap[0, 0] = -2 * Tv[0, 0] + Tv[0, 1] + Tv[1, 0]
        lap[0, -1] = -2 * Tv[0, -1] + Tv[0, -2] + Tv[1, -1]
        lap[-1, 0] = -2 * Tv[-1, 0] + Tv[-2, 0] + Tv[-1, 1]
        lap[-1, -1] = -2 * Tv[-1, -1] + Tv[-1, -2] + Tv[-2, -1]
        lap[1:-1, 0] = -3 * Tv[1:-1, 0] + Tv[:-2, 0] + Tv[2:, 0] + Tv[1:-1, 1]
        lap[1:-1, -1] = -3 * Tv[1:-1, -1] + Tv[:-2, -1] + Tv[2:, -1] + Tv[1:-1, -2]
        lap[0, 1:-1] = -3 * Tv[0, 1:-1] + Tv[0, :-2] + Tv[0, 2:] + Tv[1, 1:-1]
        lap[-1, 1:-1] = -3 * Tv[-1, 1:-1] + Tv[-1, :-2] + Tv[-1, 2:] + Tv[-2, 1:-1]
        return lap

    @staticmethod
    def _update(
        Wx: np.ndarray,
        Wy: np.ndarray,
        mode: str = None,
        info: dict = None,
        noise_flag: int = 1,
    ):
        nRow, nCol = Wx.shape
        # Euler法によるcGL方程式

        if mode == "cGL":
            a = info["a"]
            b = info["b"]
            dx = info["dx"]
            dt = info["dt"]
            D = 2.0 / dx / dx
            ni = np.sqrt(0.4 * dt)
            lapx = TFF._calc_Laplacian(Wx)  # Laplacian of Tx
            lapy = TFF._calc_Laplacian(Wy)  # Laplacian of Ty
            W2 = Wx * Wx + Wy * Wy  # |T|^2
            kWx = Wx - W2 * (Wx - b * Wy) + D * (lapx - a * lapy)
            kWy = Wy - W2 * (b * Wx + Wy) + D * (a * lapx + lapy)
            Wx = Wx + dt * kWx + np.random.normal(0, ni, (nCol, nRow)) * noise_flag
            Wy = Wy + dt * kWy + np.random.normal(0, ni, (nCol, nRow)) * noise_flag
        return Wx, Wy

    @staticmethod
    def _get_Wavefunction_in_FS(num: int, D: int) -> np.array:
        # return wave function in fourier space
        ls = (
            (2 * np.pi)
            / (D * num)
            * np.hstack(
                [
                    np.arange(0, num // 2 + 1, 1),
                    (-1) * np.arange(np.round(num / 2 + 0.1) - 1, 0, -1),
                ]
            )
        )
        return ls

    @staticmethod
    def _is_edge(x: int, y: int, nCol: int, nRow: int):
        if x == nCol // 2 + 1 or y == nRow // 2 + 1:
            return True
        return False

    @staticmethod
    def _set_observation_matrix(
        nCol: int, nRow: int, D: float, mu: float = 0.5, E: float = 5000, L: float = 0
    ):
        Kx = TFF._get_Wavefunction_in_FS(nCol, D)
        Ky = TFF._get_Wavefunction_in_FS(nRow, D)
        H = np.zeros([4 * nCol * nRow, 4 * nCol * nRow], dtype=np.float64)
        for i in range(nRow):
            for j in range(nCol):
                o = (i * nCol + j) * 4
                flag = TFF._is_edge(j, i, nCol, nRow)
                G = TFF._calc_Green(Kx[j], Ky[i], flag, mu, E)
                H[o : o + 2, o : o + 2] = G
                H[o + 2 : o + 4, o + 2 : o + 4] = G
        H[0:4, 0:4] = np.zeros([4, 4], dtype=np.float64)
        return H

    @staticmethod
    def _get_train_data(ls: list, pixel: float):
        res = []
        for df in ls:
            df.loc[:, "vx"] *= pixel
            df.loc[:, "vy"] *= pixel
            disXCF = TFF._fft_for_vectors(df, "vx").stack()
            disXR, disXI = TFF._convert_complex_to_vectors(disXCF)
            disYCF = TFF._fft_for_vectors(df, "vy").stack()
            disYR, disYI = TFF._convert_complex_to_vectors(disYCF)
            obsCF = (
                pd.concat([disXR, disYR, disXI, disYI]).sort_index().astype("float64")
            )
            res.append(obsCF.values)
        return res

    @staticmethod
    def _convert_complex_to_vectors(df: pd.DataFrame):
        R = df.apply(lambda x: x.real)
        I = df.apply(lambda x: x.imag)
        return R, I

    @staticmethod
    def _fft_for_vectors(df: pd.DataFrame, target: str):
        Vec = df.rearrange_by_coordinate(target)
        return pd.DataFrame(np.fft.fft2(Vec))

    def get_Dimensions(self) -> list:
        return super().get_Dimensions()

    def confirm(self):
        return TFF(super().confirm())

    def rearrange_by_coordinate(self, target: str) -> pd.DataFrame:
        # return the target data in 2D (x is column and y is row)
        return super().rearrange_by_coordinate(target)

    def draw(self, scale: int = None, save_img: bool = False, name: str = None):
        super().draw(scale=scale, save_img=save_img, name=name)

